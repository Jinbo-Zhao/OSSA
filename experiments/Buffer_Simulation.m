%The code is created by Anjie Guo and updated by Anna Dong from Cornell
%University.
%It is modified to work as an problem instance for OSSA (One-shot Screening for Acceptability)
function [AvgUtility,NumDiscarded,AverageWaitingTime] = Buffer_Simulation(solution, runlength, seed)
% function [fn, FnVar, FnGrad, FnGradCov, constraint, ConstraintCov, ConstraintGrad, ConstraintGradCov] = Buffer(x, runlength, seed, other);

%% -- INPUTS:
% x is a vector of the buffer limit for each node % 
% runlength is the number of replications to simulate %
% seed is the index of the substreams to use (integer >= 1) %
% other is not used

%% -- OUTPUTS:
% RETURNS fn and FnVar, throughput are variance in customers/minute

%% -- CHECK FOR ERRORS; assume x generated by Voting Structure and is okay

% B = 20; % total number of buffer spots %buffer 
% x = [x(1),x(1),x(1),x(1),x(2),x(3),x(2),x(3),x(4)];
% x = [x, B-sum(x)]; %buffer size of the 10 nodes
x=solution;
if (runlength <= 0) || (seed <= 0) || (round(seed) ~= seed)
    fprintf('runlength should be positive and real, seed should be a positive integer\n');
    fn = NaN;
    FnVar = NaN;
else % main simulation
    
    %% *********************PARAMETERS*********************
    nRuns=runlength;
    n=10;                         %number of nodes
    warmup=2000;                  %# of cust. enter empty system before counting
    test=1000;                    %test time for 100 cust to go through system after warmup
    C2mean=1/.48;                 %C2 has interarrival times exp with rate .12 
    svcmean=1/.5;                 %nodes 8,9 have exponential serv time with rate .5
    MaxSpots= x + 1;              %x buffer spots + 1 server
    %% GENERATE RANDOM NUMBER STREAMS
    % Generate new streams for call arrivals, call
    [Arrival1Stream, Arrival2Stream, Service1Stream, Service2Stream, FirstNodeStream] = RandStream.create('mrg32k3a', 'NumStreams', 5);
    % Set the substream to the "seed"
    Arrival1Stream.Substream = seed;
    Arrival2Stream.Substream = seed;
    Service1Stream.Substream = seed;
    Service2Stream.Substream = seed;
    FirstNodeStream.Substream = seed;
    
    
    %% RUN SIMULATIONS
    %Tracks performance times for each run
    %MakeSpan=zeros(nRuns,1);
    AvgUtility=zeros(nRuns,1);
    NumDiscarded=zeros(nRuns,1);

    for k=1:nRuns
        %arrival time | arrival node | customer type
        Cnew = generateCMatrix(Arrival1Stream, Arrival2Stream, Service1Stream, Service2Stream, FirstNodeStream, C2mean, svcmean);
        time=0;
        entered=0;                      %
        start=0;                        %start time after 2000 have entered system
        completed=0;                    %count up to 100 have exited system after initial 2000 warmup
        Spots=MaxSpots;                 %number of empty buffer spots+1 server spot at node
        %
        Filled=zeros(n,max(MaxSpots));    %reference/id to the customer in that buffer position
        %server 
        server=zeros(n, 2); % col 1-#customers being served & waiting; col 2-time when finish serving current customer, -1 if not serving any
        server(:,2)=-1;

        server_tracking = cell(n,1);
        for server_tracking_rep=1:n
            server_tracking{server_tracking_rep}=zeros(1,2);
        end

        timeTracker=ones(n+1,1)*-1; %service ending time for the 10 nodes & arrival time of next customer
        %prioritylist = zeros(6,10); %to keep track the first blocked
        ref = 1; %initialize

        start = time;
        Num_abonded_customer=0;
        while  time <= warmup+test
            
           
            timeTracker(end) = Cnew(ref,1);
            time = min(timeTracker(timeTracker>0));

        
            if sum(time==timeTracker(9:10))>0 %customers finish service at stage 3
                %determine final node
                k3 = 9;
                if time~=timeTracker(k3)
                  k3 = 10;
                end
                %leave
                
                if time>warmup
                    completed = completed + 1;
                     customer_to_leave=Filled(k3,1);
                     service_time=time-Cnew(customer_to_leave,1);%
                     waiting_time=service_time-sum(Cnew(customer_to_leave,4:6));%
                     service_perfomrance_list(completed,:)=[customer_to_leave,service_time,waiting_time];

                    
                end

                Filled(k3,:)=[Filled(k3,2:end),0];%
                server(k3,1)=server(k3,1)-1;%
                if server(k3,1) == 0%
                    server(k3,2) = -1;
                    server_tracking{k3}=[server_tracking{k3};[0,time]];
                else
                    ref44=Filled(k3,1);%
                    server(k3,2)=time+Cnew(ref44,6);%

                end
                timeTracker(k3) = server(k3,2);%
                
                
                

            elseif sum(time==timeTracker(5:8))>0 %customers finish service at stage 2
                %determine stage3 node
                k2 = 4;
                while k2<=8%
                    k2=k2+1;
                    if time==timeTracker(k2)%
                        ref3 = Filled(k2,1);%
                        if Cnew(ref3,3)==1 %if type1
                            node3=9;
                        else
                            node3=10;
                        end
                        break; 
                    end
                end

                pos = find(Filled(node3,:)==0, 1,'first'); % the position of first empty buffer/
                if pos<=Spots(node3) % there is buffer space available at stage3%
                    Filled(node3,pos) = ref3;
                    server(node3,1) = pos;

                    if pos == 1 % if this customer is being served (stage 3)%
                        server(node3,2) = time+Cnew(ref3,6); %stage3 service time
                        timeTracker(node3) = server(node3,2);
                        server_tracking{node3}=[server_tracking{node3};[1,time]];
                    end

                    % leave stage2
                    Filled(k2,:)=[Filled(k2,2:end),0];
                    server(k2,1)=server(k2,1)-1;
                    if server(k2,1) == 0
                        server(k2,2) = -1;
                        server_tracking{k2}=[server_tracking{k2};[0,time]];
                    else
                        ref33=Filled(k2,1);
                        server(k2,2)=time+Cnew(ref33,5);%stage2 service time
                    end
                    timeTracker(k2) = server(k2,2);
                else % there is not enough space at node3/stage3
                    % have to stay in the server at node2. so update the time to node3 service ending time
                    server(k2,2)=server(node3,2);
                    timeTracker(k2) = server(k2,2);
                    server_tracking{k2}=[server_tracking{k2};[0,time];[1,server(node3,2)]];
                    %prioritylist = [prioritylist, node3];
                end
                
            elseif sum(time==timeTracker(1:4))>0    % Customers finish service at stage 1
                %determine stage2 node
                k1 = 0;
                while k1<=4
                    k1=k1+1;
                    if time==timeTracker(k1)
                        ref2 = Filled(k1,1);
                        if k1<=2
                            if Cnew(ref2,3)==1 %if type1 cust
                                node2=5;
                            else
                                node2=6;
                            end
                        else
                            if Cnew(ref2,3)==1 %if type1 cust
                                node2=7;
                            else
                                node2=8;
                            end
                        end
                        break;
                    end
                end
                pos = find(Filled(node2,:)==0, 1,'first'); % the position of first empty buffer
                if pos<=Spots(node2) % there is buffer space available at stage2
                    Filled(node2,pos) = ref2;
                    server(node2,1) = pos;
                    if pos == 1 % if this customer is being served (stage 2)
                        server(node2,2) = time+Cnew(ref2,5); %stage2 service time
                        timeTracker(node2) = server(node2,2);
                        server_tracking{node2}=[server_tracking{node2};[1,time]];
                    end
                    % leave stage1
                    Filled(k1,:)=[Filled(k1,2:end),0];
                    server(k1,1)=server(k1,1)-1;
                    if server(k1,1) == 0
                        server(k1,2) = -1;
                        server_tracking{k1}=[server_tracking{k1};[0,time]];
                    else
                        ref22=Filled(k1,1);
                        server(k1,2)=time+Cnew(ref22,4);%stage1 service time                        
                    end
                    timeTracker(k1) = server(k1,2);
                else % there is not enough space at node2/stage2
                    % have to stay in the server at node1. so update the time to node2 service ending time
                    server(k1,2)=server(node2,2);
                    timeTracker(k1) = server(k1,2);
                    server_tracking{k1}=[server_tracking{k1};[0,time];[1,server(node2,2)]];
                    %prioritylist = [prioritylist, node2];
                end
                
            elseif time==timeTracker(end)  % if Customers arrive Nodes 1~4//stage1
                entered = entered + 1;
                arrNode1 = Cnew(ref,2);
                pos = find(Filled(arrNode1,:)==0, 1,'first'); % the position of first empty buffer
                if pos<=Spots(arrNode1) % there is buffer space available
                    Filled(arrNode1,pos) = ref;
                    server(arrNode1,1) = pos;
                    if pos == 1 % if this customer is being served (stage 1)
                        server(arrNode1,2) = time+Cnew(ref,4);
                        timeTracker(arrNode1) = server(arrNode1,2);
                        server_tracking{arrNode1}=[server_tracking{arrNode1};[1,time]];
                    end
                else % there is not enough space for the arrNode1
                    if time>warmup
                        Num_abonded_customer=Num_abonded_customer+1;% skip this customer//customer is blocked
                    end
                end
                ref=ref+1; % time for next customer
                
            else
                fprintf('not belonging to any if statements\n'); % can be removed after debugging
                
            end
        end
        utility = utility_calculation(server_tracking,warmup,test);
        



         TimeInSystem(k)=mean(service_perfomrance_list(:,2));
         AverageWaitingTime(k)=mean(service_perfomrance_list(:,3));
%         MaxWaitingTime(k)=max(service_perfomrance_list(:,3));
        NumDiscarded(k)=Num_abonded_customer;
        AvgUtility(k)=mean(utility);
        
    end
end

%% Generate random data
% C stores the interarrival and service times. 2nd dimension is
% [arrival,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Stage 1 service, Stage 2 service, Stage 3 service], and 3rd
% dimension is [Class 1 customers, Class 2 customers].
    function Cnew = generateCMatrix(Arrival1Stream, Arrival2Stream, Service1Stream, Service2Stream, FirstNodeStream, C2mean, svcmean)
        numGenerate =10000; %number of customer info to generate at a time%
        C=zeros(2*numGenerate,6);
        %2*numGenerate rows & 6 cols: arrival time | arrival node (1~4)
        % | customer type (1 or 2) | service time stage 1 | service time stage 2 | service time stage 3
        OldStream = RandStream.setGlobalStream(Arrival1Stream);     % Temporarily store old stream
        %
        arrivalTime1 = 3*rand(numGenerate,1)+1;                             % C1 has interarrival times uniform [2, 9]
        for kc1 = 2:numGenerate
            arrivalTime1(kc1) = arrivalTime1(kc1) + arrivalTime1(kc1-1);
        end
        
        RandStream.setGlobalStream(Arrival2Stream);
        arrivalTime2=exprnd(C2mean,numGenerate,1);                            % C2 interarrival times exponential
        %
        for kc2 = 2:numGenerate
            arrivalTime2(kc2) = arrivalTime2(kc2) + arrivalTime2(kc2-1);
        end
        C(:,1) = [arrivalTime1; arrivalTime2];
        %

        RandStream.setGlobalStream(FirstNodeStream);
        %
        C(:,2) = unidrnd(4,2*numGenerate,1);
        %
        C(1:numGenerate, 3) = 1;
        C(numGenerate+1:end,3) = 2;
        %
        RandStream.setGlobalStream(Service1Stream);                 % Service times for stage 1 and 2 (nodes 0-7)
        C(:,4:5) = 4*rand(2*numGenerate,2)+3;                              % Uniform [3, 7]
        
        RandStream.setGlobalStream(Service2Stream);                 % Service times for stage 3 (nodes 8,9)
        C(:,6) = exprnd(svcmean,2*numGenerate,1);
        
        RandStream.setGlobalStream(OldStream);                      % Restore old random number stream
        
        %
        %2*numGenerate rows & 6 cols: 
        % arrival time | arrival node (1~4） | customer type (1 or 2) | service time stage 1 | service time stage 2 | service time stage 3
        [~,indc]=sort(C,1);
        indc2 = indc(:,1);
        Cnew = C(indc2,:);
    end
%% Utility Calculation
    function utility = utility_calculation(server_tracking,warmup,test)
        num_server=size(server_tracking,1);
        utility=zeros(num_server,1);
        for rep=1:num_server
            status_rec=server_tracking{rep};
            status_rec=status_rec(status_rec(:,2)>warmup,:);

            if status_rec(end,1)==1
               status_rec=[status_rec;[0,warmup+test]];
            end

            if status_rec(1,1)==1
                idle_times=status_rec(2:2:end,2);%
                busy_times=status_rec(1:2:end,2);%
                utility(rep,1)=sum(idle_times-busy_times)/test;
            else
                idle_times=status_rec(1:2:end,2);%
                busy_times=status_rec(2:2:end,2);%
                busy_times=[warmup;busy_times];
                utility(rep,1)=sum(idle_times-busy_times)/test;
            end
        end
    end
end

